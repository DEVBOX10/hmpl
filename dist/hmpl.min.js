!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,t=e=>"[object Function]"===Object.prototype.toString.call(e),o=e=>{throw new Error(e)},n=e=>{console.warn(e)},r="src",s="method",i="initId",l="after",d="repeat",c="memo",a="indicators",p="autoBody",f="hmpl",h="formData",u="disallowedTags",m="sanitize",y="allowedContentTypes",$="get",g="interval",b="BadResponseError",v="RequestInitError",w="RenderError",T="RequestComponentError",N="CompileOptionsError",O="ParseError",P="CompileError",E={formData:!0},j={formData:!1},x=[r,s,i,l,d,a,c,p,y,u,m,g],k=[100,101,102,103,300,301,302,303,304,305,306,307,308,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,421,422,423,424,425,426,428,429,431,451,500,501,502,503,504,505,506,507,508,510,511],I=["script","style","iframe"],A=["text/html"],C=[],q=(e,t=!1)=>{let o=e;t&&(o=DOMPurify.sanitize(e));return(new DOMParser).parseFromString(`<template>${o}</template>`,"text/html").childNodes[0].childNodes[0].firstChild},D=(t,r,s,i,l,d,c,a,p={},f,h,u,m,y,$,g)=>{const{mode:w,cache:T,redirect:N,get:O,referrerPolicy:P,signal:E,credentials:j,timeout:x,referrer:k,headers:I,body:A,window:C,integrity:D}=p,S={method:i.toUpperCase()};void 0!==j&&(S.credentials=j),void 0!==A&&(S.body=A),void 0!==w&&(S.mode=w),void 0!==T&&(S.cache=T),void 0!==N&&(S.redirect=N),void 0!==P&&(S.referrerPolicy=P),void 0!==D&&(S.integrity=D),void 0!==k&&(S.referrer=k);const F=void 0!==E;if(F&&(S.signal=E),void 0!==C&&(S.window=C),void 0!==p.keepalive&&n(`${v}: The "keepalive" property is not yet supported`),I)if(e(I)){const e=new Headers;for(const t in I){const n=I[t],r=typeof n;"string"===r?e.set(t,n):o(`${v}: Expected type string, but received type ${r}`)}S.headers=e}else o(`${v}: The "headers" property must contain a value object`);x&&(F?n(`${v}: The "signal" property overwrote the AbortSignal from "timeout"`):S.signal=AbortSignal.timeout(x));const M=a&&!d&&s?.memo,B=e=>"rejected"===e||"number"==typeof e&&(e<200||e>299),z=R(void 0,g),L=e=>{c&&(y.response=e,O?.("response",e,z,y)),O?.("response",r,z)},U=(e,o=!0,n=!1)=>{if(d)f.response=e.cloneNode(!0),O?.("response",e,z);else{let r=[];const i=[...(o?e.cloneNode(!0):e).content.childNodes];if(s.nodes){const e=s.parentNode,t=[],o=s.nodes.length;for(let n=0;n<o;n++){const r=s.nodes[n];if(n===o-1)for(let o=0;o<i.length;o++){const n=i[o],s=e.insertBefore(n,r);t.push(s)}e.removeChild(r)}r=t.slice(),s.nodes=t}else{const e=t.parentNode,o=[],n=i.length;for(let r=0;r<n;r++){const n=i[r],s=e.insertBefore(n,t);o.push(s)}e.removeChild(t),r=o.slice(),s.nodes=o,s.parentNode=e}M&&n&&(s.memo.nodes=s.nodes,s.memo.isPending&&(s.memo.isPending=!1)),L(r)}};let H=!1;const W=()=>{if(d)f.response=void 0,O?.("response",void 0,z);else if(s?.nodes){const e=s.parentNode,t=s.nodes.length;for(let o=0;o<t;o++){const n=s.nodes[o];o===t-1&&e.insertBefore(s.comment,n),e.removeChild(n)}s.nodes=null,s.parentNode=null,c&&(y.response=void 0,O?.("response",void 0,z,y)),O?.("response",r,z)}M&&null!==s.memo.response&&(s.memo.response=null,delete s.memo.isPending,delete s.memo.nodes)},_=e=>{c?y.status!==e&&(y.status=e,O?.("status",e,z,y)):f.status!==e&&(f.status=e,O?.("status",e,z)),M&&B(e)&&(s.memo.response=null,delete s.memo.nodes),(e=>{if($)if(M&&"pending"!==e&&B(e)&&s.memo.isPending&&(s.memo.isPending=!1),"pending"===e){const e=$.pending;void 0!==e&&(M&&(s.memo.isPending=!0),U(e))}else if("rejected"===e){const e=$.rejected;if(void 0!==e)U(e);else{const e=$.error;void 0!==e?U(e):W()}}else{const t=$[`${e}`];if(e>399)if(void 0!==t)U(t);else{const e=$.error;void 0!==e?U(e):W()}else(e<200||e>299)&&(H=!0,void 0!==t?U(t):W())}})(e)};let G=200;_("pending");let V=!0,J=!0;fetch(l,S).then((e=>{if(V=!1,G=e.status,_(G),e.ok||($&&(J=!1),o(`${b}: Response with status code ${G}`)),Array.isArray(h)&&0!==h.length){const t=e.headers.get("Content-Type");((e,t)=>{if(!e)return!0;let o=!1;for(let n=0;n<t.length;n++){const r=t[n];if(e.includes(r)){o=!0;break}}return!o})(t,h)&&o(`${b}: Expected ${h.map((e=>`"${e}"`)).join(", ")}, but received "${t}"`)}return e.text()})).then((e=>{if(!H){if(M){const{response:t}=s.memo;if(null===t)s.memo.response=e;else{if(t===e)return void(()=>{if(s.memo.isPending){const e=s.parentNode,t=s.memo.nodes,o=s.nodes,n=o.length,r=[];for(let s=0;s<n;s++){const i=o[s];if(s===n-1)for(let o=0;o<t.length;o++){const n=t[o],s=e.insertBefore(n,i);r.push(s)}e.removeChild(i)}s.nodes=r.slice(),s.memo.isPending=!1,s.memo.nodes=r.slice()}const e=s.nodes.slice();L(e)})();s.memo.response=e,delete s.memo.nodes}}const o=((e,t=[],o)=>{const n=q(e,o),r=n.content;for(let e=0;e<t.length;e++){const o=t[e],n=r.querySelectorAll(o);for(let e=0;e<n.length;e++)r.removeChild(n[e])}return n})(e,u,m);if(d)f.response=o,O?.("response",o,z);else{const e=[],n=[...o.content.childNodes];if(s)U(o,!1,!0);else{const o=t.parentNode;for(let r=0;r<n.length;r++){const s=n[r],i=o.insertBefore(s,t);c&&e.push(i)}o.removeChild(t),c&&(y.response=e,O?.("response",e,z,y)),O?.("response",r,z)}}}})).catch((e=>{throw V?(_("rejected"),$||W()):J&&W(),e}))},R=(e,t)=>{const o={};return void 0!==e&&(o.event=e),t&&(o.clearInterval=t),{request:o}},S=(n,a,h,$,b,N,P,x,I,S=!1)=>{const L=(n,a)=>{const f=n[r];if(f){const r=(n[s]||"GET").toLowerCase();if(!(e=>"get"!==e&&"post"!==e&&"put"!==e&&"delete"!==e&&"patch"!==e)(r)){const s=n[l];s&&S&&o(`${w}: EventTarget is undefined`);const h=!n.hasOwnProperty(d),O="all"===(!!h||n[d]?"all":"one"),L=n[g],H=!n.hasOwnProperty(c),W=!n.hasOwnProperty(g);let _=!b&&$[c];H?_&&(s&&O||(_=!1)):s?n[c]?O?_=!0:o(`${T}: Memoization works in the enabled repetition mode`):_=!1:o(`${T}: Memoization works in the enabled repetition mode`),W||O&&s&&o(`${T}: The "${g}" property does not work with repetiton mode yet`);const G=!n.hasOwnProperty(p);let V=!N&&$[p];if(G)!0===V&&(V=E),s||(V=!1);else if(s){let e=n[p];if(M(e),!0===V&&(V=E),!0===e&&(e=E),!1===e)V=!1;else{const t={...!1===V?j:V,...e};V=t}}else V=!1,o(`${T}: The "${p}" property does not work without the "${l}" property`);const J=!n.hasOwnProperty(y);let X=P?A:$[y];if(!J){const e=n[y];F(e),X=e}const Z=!n.hasOwnProperty(u);let K=x?C:$[u];if(!Z){const e=n[u];B(e),K=e}const Q=!n.hasOwnProperty(m);let Y=!I&&$[m];if(!Q){const e=n[m];z(e),Y=e}const ee=n[i],te=n.nodeId;let oe=n.indicators;if(oe){const e=e=>{const{trigger:t,content:n}=e;t||o(`${T}: Failed to activate or detect the indicator`),n||o(`${T}: Failed to activate or detect the indicator`),-1===k.indexOf(t)&&"pending"!==t&&"rejected"!==t&&"error"!==t&&o(`${T}: Failed to activate or detect the indicator`);const r=q(n);return{...e,content:r}},t={},n=[];for(let r=0;r<oe.length;r++){const s=e(oe[r]),{trigger:i}=s;-1===n.indexOf(i)?n.push(i):o(`${T}: Indicator trigger must be unique`),t[`${i}`]=s.content}oe=t}const ne=(e,t=!1)=>{if(t){if(ee){let t;for(let o=0;o<e.length;o++){const n=e[o];if(n.id===ee){t=n.value;break}}return t||o(`${T}: ID referenced by request not found`),t}return{}}return ee&&o(`${T}: ID referenced by request not found`),e},re=void 0!==L,se=O&&s||re,ie=(n,s,i,l,d,c=!1,p,h=!1,u,m,y)=>{const $=l.currentId;if(S)n||(n=a);else if(!n){let e;const{els:t}=l;for(let o=0;o<t.length;o++){const n=t[o];if(n.id===te){u=n,e=n.el;break}}n=e}let g;S||(se||oe)&&(g=u.objNode,g||(g={id:$,nodes:null,parentNode:null,comment:n},_&&(g.memo={response:null},oe&&(g.memo.isPending=!1)),re&&y&&(g.interval={value:y,clearInterval:()=>clearInterval(y)}),u.objNode=g,l.dataObjects.push(g),l.currentId++));let b=ne(s,c);const w=t(b);if(!w&&b&&(b={...b}),V&&V.formData&&m&&!w){const{type:e,target:t}=m;"submit"===e&&t&&t instanceof HTMLFormElement&&"FORM"===t.nodeName&&(b.body=new FormData(t,m.submitter))}let T=y?()=>clearInterval(y):void 0;T=S?T:g?.interval?.clearInterval;const N=w?((e,t,o)=>e(R(t,o)))(b,m,T):b;e(N)||void 0===N||o(`${v}: Expected an object with initialization options`),D(n,d,g,r,f,S,h,_,N,i,X,K,Y,p,oe,T)};let le=ie;if(L){U(L);const e=Number(L);le=(t,o,n,r,s,i=!1,l,d=!1,c,a)=>{let p=null;p=setInterval((()=>{ie(t,o,n,r,s,i,l,d,c,a,p)}),e)}}let de=le;if(s){const e=(e,t,n,r,s,i,l,d,c,a,p)=>{const f=c.querySelectorAll(n);0===f.length&&o(`${w}: Selectors nodes not found`);const h=O?t=>{le(e,r,s,i,c,l,a,d,p,t)}:o=>{le(e,r,s,i,c,l,a,d,p,o);for(let e=0;e<f.length;e++){f[e].removeEventListener(t,h)}};for(let e=0;e<f.length;e++){f[e].addEventListener(t,h)}};if(s.indexOf(":")>0){const t=s.split(":"),o=t[0],n=t.slice(1).join(":");de=(t,r,s,i,l,d=!1,c,a=!1,p)=>{e(t,o,n,r,s,i,d,a,l,c,p)}}else o(`${T}: The "${l}" property doesn't work without EventTargets`)}else h||o(`${T}: The "${d}" property doesn't work without "${l}" property`);return de}o(`${T}: The "${s}" property has only GET, POST, PUT, PATCH or DELETE values`)}else o(`${T}: The "${r}" property are not found or empty`)};let H;if(S)h[0].el=n,H=L(h[0]);else{let e=-2;const t=n=>{if(e++,8==n.nodeType){let t=n.nodeValue;if(t&&t.startsWith(f)){t=t.slice(4);const r=Number(t),s=h[r];(Number.isNaN(r)||void 0===s)&&o(`${O}: Request object with id "${r}" not found`),s.el=n,s.nodeId=e}}if(n.hasChildNodes()){const e=n.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};if(t(n),h.length>1){const e=[];for(let t=0;t<h.length;t++){const o=h[t];e.push(L(o,n))}H=(t,o,n,r,s,i=!1)=>{t||(t=s);const l=[],d=r.els;for(let s=0;s<d.length;s++){const c=d[s],a=c.el,p={response:void 0};(0,e[s])(a,o,n,r,t,i,p,!0,c),l.push(p)}n.requests=l}}else{H=L(h[0],n)}}return a(H)},F=(e,t=!1)=>{const n=t?N:T;"*"===e||((e,t)=>{if(!Array.isArray(e))return!1;let n=!0;for(let r=0;r<e.length;r++)if("string"!=typeof e[r]){o(`${t}: In the array, the element with index ${r} is not a string`),n=!1;break}return n})(e,n)||o(`${n}: Expected "*" or string array, but got neither`)},M=(t,n=!1)=>{const r=e(t),s=n?N:T;if("boolean"==typeof t||r||o(`${s}: Expected a boolean or object, but got neither`),r)for(const e in t)if(e===h)"boolean"!=typeof t[h]&&o(`${s}: The "${h}" property should be a boolean`);else o(`${s}: Unexpected property "${e}"`)},B=(e,t=!1)=>{const n=t?N:T;Array.isArray(e)||o(`${n}: The value of the property "${u}" must be an array`);for(let t=0;t<e.length;t++){const r=e[t];I.includes(r)||o(`${n}: The value "${r}" is not processed`)}},z=(e,t=!1)=>{"boolean"!=typeof e&&o(`${t?N:T}: The value of the property "${m}" must be a boolean`)},L=e=>{e.hasOwnProperty("id")&&e.hasOwnProperty("value")||o(`${v}: Missing "id" or "value" property`)},U=e=>{"number"!=typeof e&&o(`${T}: The "${g}" value must be number`)};return{compile:(n,r={})=>{"string"!=typeof n&&o(`${P}: Template was not found or the type of the passed value is not string`),n||o(`${P}: Template must not be a falsey value`),e(r)||o(`${N}: Options must be an object`);const s=!r.hasOwnProperty(c);s||"boolean"==typeof r[c]||o(`${N}: The value of the property ${c} must be a boolean`);const l=!r.hasOwnProperty(p);l||M(r[p],!0);const h=!r.hasOwnProperty(y);h||F(r[y],!0);const b=!r.hasOwnProperty(u);b||B(r[u],!0);const E=!r.hasOwnProperty(m);E||z(r[m],!0);const j=[],k=[],I=e=>{let t="";const o=/\s*([a-zA-Z0-9_-]+)\s*=\s*(("[^"]*"|'[^']*'|`[^`]*`|\[[^\]]*\]|\{[^}]*\}|true|false|\d+)(?=\s|,|$))\s*/g;let n;for(;null!==(n=o.exec(e));){t+=`${n[1].trim()}:${n[2].trim()},`}return t.replace(/,$/,"").trim()},A=(e=>{const t=[];let n=0;const r=[{open:"{{#request",close:"{{/request}}"},{open:"{{#r",close:"{{/r}}"}];for(;n<e.length;){const s=r.map((t=>({...t,index:e.indexOf(t.open,n)}))).filter((e=>-1!==e.index));if(0===s.length){t.push(e.slice(n));break}const i=s.sort(((e,t)=>e.index-t.index))[0];t.push(e.slice(n,i.index));const l=i.index+i.open.length,d=e.indexOf("}}",l);-1===d&&o(`${O}: Unclosed block (no ending '}}') for ${i.open}`);const c=e.slice(l,d).trim(),a=e.indexOf(i.close,d);-1===a&&o(`${O}: No closing '${i.close}' found for ${i.open}`);e.slice(d+2,a).includes(i.open)&&o(`${O}: Nested ${i.open}}} blocks are not supported`);const p=I(c);t.push(`{${p}}`),k.push(t.length-1),n=a+i.close.length}return t})(n);0===k.length&&o(`${O}: Request object not found`);const C=e=>{const t=JSON5.parse(e);for(const e in t){const n=t[e];switch(x.includes(e)||o(`${T}: Property "${e}" is not processed`),e){case a:Array.isArray(n)||o(`${T}: The value of the property "${e}" must be an array`);break;case i:"string"!=typeof n&&"number"!=typeof n&&o(`${T}: The value of the property "${e}" must be a string`);break;case c:case d:"boolean"!=typeof n&&o(`${T}: The value of the property "${e}" must be a boolean value`);break;case p:M(n);break;case y:F(n);break;case u:B(n);break;case m:z(n);break;case g:U(n);break;default:"string"!=typeof n&&o(`${T}: The value of the property "${e}" must be a string`)}}const n={...t};j.push(n)};for(let e=0;e<k.length;e++){const t=k[e];C(A[t]);const o=`\x3c!--hmpl${e}--\x3e`;A[t]=o}n=A.join("");let D=!1;const R=(e=>{const t=q(e.trim());(t.content.childNodes.length>1||1!==t.content.children.length&&8!==t.content.childNodes[0].nodeType)&&o(`${w}: Template includes only one node of the Element type or one response object`);const n=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("PRE"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)n(e.childNodes.item(t))};n(t.content.childNodes[0]);let r=t.content.firstElementChild;if(!r){const e=t.content.firstChild;8===e?.nodeType&&(D=!0,r=e)}return r})(n);return S(R,(n=>(r={})=>{const s=R.cloneNode(!0),i={response:D?void 0:s},l={dataObjects:[],els:[],currentId:0};if(!D){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith(f)){const t={el:o,id:e};l.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(s)}var d;return e(r)||t(r)?(e(d=r)&&d.hasOwnProperty(`${$}`)&&(t(d[$])||o(`${v}: The "${$}" property has a function value`)),n(void 0,r,i,l,s)):Array.isArray(r)?((t=>{const n=[];for(let r=0;r<t.length;r++){const s=t[r];e(s)||o(`${v}: IdentificationRequestInit is of type object`),L(s);const{id:i}=s,l="string"==typeof s.id;l||"number"==typeof s.id||o(`${v}: ID must be a string or a number`),n.indexOf(i)>-1?o(`${v}: ID with value ${l?`"${i}"`:i} already exists`):n.push(i)}})(r),n(void 0,r,i,l,s,!0)):o(`${v}: The type of the value being passed does not match the supported types for RequestInit`),i}),j,r,s,l,h,b,E,D)},stringify:e=>{const t=e=>"string"==typeof e?`"${e}"`:"number"==typeof e||"boolean"==typeof e?`${e}`:Array.isArray(e)?`[${e.map((e=>t(e))).join(",")}]`:"object"==typeof e&&null!==e?`{${Object.entries(e).map((([e,o])=>`${e}:${t(o)}`)).join(",")}}`:"";let o=Object.entries(e).map((([e,o])=>`${e}=${t(o)}`)).join(" ");return o.endsWith("}")&&(o+=" "),`{{#request ${o}}}{{/request}}`}}}()}));